
# 面试技能点答题要点 #

----------

## 1.面向对象 ##
1. 阐述面向对象的思想---》举例公司雇佣
2. 三大特性，好处。多态的局限性。


----------
## 2.集合 ##
1. 集合结构图。
2. 相比较数组的特点。
3. list集合特点，子类底层结构，使用特点，确定元素唯一性的方法
4. set集合特点，子类底层结构，确定元素唯一性的方法，treeset的两种比较方式
5. MAP集合子类的底层结构，元素两种取出方式。  普通for  增强for
6. 单列集合，双列集合
7. 数组和集合工具类

## 3.IO流 ##
1. 常用的流，及其作用

## 4.多线程 ##
1. 进程和线程的关系
2. 创建线程的方式三种
3. 线程运行状态四种。
4. 线程安全，原因
5. 线程同步方案
6. 线程间通信概念
7. 单线程存数据，单线程取数据。普通等待唤醒机制。不能解决多线程存，多线程去问题，出现死锁问题。出现的原因就是等待唤醒机制唤醒方法部不分敌我的唤醒。
8. 多线程存，多线程去。升级版等待唤醒机制，分组。这样存的线程唤醒方法只能唤醒存的线程，取的线程唤醒方法只唤醒取的线程。
9. 安卓进程分级。
10. 线程间通信，使用Lockj

## 5.四大组件 ##
1. 内容提供者的作用，内容提供者数据变化可被监听。


2. activity，启动模式
3. activity，生命周期七个方法
4. 内存不足的进程回收机制。


5. 广播接受者的创建
6. 广播接受者注册方式以及速度
7. 无序广播，有序广播，特点
8. 自定义权限
9. 广播接受者生命周期，耗时操作处理


10. service概念，使用环境
11. 两种方式开启的生命周期，四个。
12. 两种方式开启与当前activity的关系。
13. 绑定方式开启相对于start方式开启的优势。

## 6.异步加载网络数据 ##
AsyncTask，线程池+handler消息机制

## 7.listview ##
1. 优化的原因。 
2. 缓存view优化原理：创建与屏幕大小相等的item后，缓存。手机listview举例。
3. 保存引用优化原理：原因，static的使用。少量的view可以使用，大量的view不建议使用，因为被static 修饰的成员变量生命周期长，当对象销毁时，只要内存中还存在该类的字节码文件，这些引用还在，但是已经没有用了。
4. 加载数据优化，listview分批分页加载数据。原因，具体实现的监听。
5. 复杂listview的两种处理方式，根据位置设置不同的view，根据判断条件是否显示控件。
6. listview图片加载问题，闪烁，新线程从网络上加载图片网络延时没有及时覆盖掉缓存view的设置，交错，老线程加载图片的速度比新线程加载图片的速度慢所致。  使用tag
7. listview加载图片优化,缩放，软引用。异步+缓存机制			加载图片。
8. 缓存机制，从网路上获取图片后存放到本地，通过缩放后的图片加载到缓存中，加载前判断缓存是否超出了内存限制，如果超出就取出最少使用的图片，直到小于缓存，再次获取图片是，先从内存中查找是否有图片，内存中如果没有去缓存文件中找是否有，如果没有，那么就请求网络获取图片  XUTILS图片加载原理
## 7.熟悉XML/JSON解析数据，以及数据存储方式  
安卓数据存储方式，五种。
xml解析，pullparser,sierializer
json解析，json生成


## 8，优化内存对象引用级别 ##
1. 强引用
2. 软引用
3. 弱引用
4. 虚引用

## 9.OOM异常，内存溢出 ##
1. 根本原因，程序运行需要的内存大于虚拟机所能提供的最大内存。
2. 常见引起的原因：
> 普通成员变量资源引用不释放，发生内存泄露，当该类的对象销毁时才释放资源;


> 如果是static修饰的成员变量，生命周期与类，也就是字节码文件相同，会发生时间更为持久的内存泄露,因此尽量避免static成员变量引用耗费资源大的对象;


> 加载大对象，如图片。加载时option等比例缩放,软引用图片对象和回收

> 线程导致内存溢出。如果一个A对象引用了另外一个B对象，那么B对象不销毁，A对象也无法销毁，A对象内部的对象销毁全部销毁A对象才能销毁,因此A对象内部的对象如果生命周期非常长的话将致使A对象无法释放。在一个类中使用子线程来进行耗时操作，线程对象的生命周期与run方法执行的任务有关，如果耗时任务没有完成，那么线程对象就不会销毁，而线程对象持有当前类对象的引用this,因此当前类对象也无法销毁。

AsyncTask内部使用线程池，生命周期不可控制，因此更容易出现内存溢出异常。

建议使用ApplicationContext代替  Context,使用后者会保存对当前activity的引用，影响activity对象的释放。


线程对象的内部类可以使用静态来修饰，这样内部类的生命周期与当前类的生命周期一样，因此当类对象销毁时，线程对象也肯定销毁，不会管run方法有没有执行完。



## 10.消息推送 ##
概念，方式
pull方式的实现及缺点
push的方式的实现  GOOGL C2DM    第三方激光推送push

消息推送机制即，移动端与服务器端维护一个异步请求的长连接，当查询到有更新的数据时，将数据发往移动短。

两种方式：pull  push  
pull ; 客户端没间隔一段时间轮询服务器，消耗电量和资源
push维护socket长连接，行跳帧机制确保连接存在
小公司使用第三方服务器推送，如百度推送，极光推送，但是受制于人
使用自己的服务器推送消息，安装xmpp协议的 androidpn服务器   使用它的推送消息模块。
androidpn客户端是在一个service里面维护一个长连接，消息到来时是以发送广播的方式提示系统那个的。

## 11.屏幕适配 ##
五种方式，不同分辨率的图片文件夹，不同分辨率的布局文件，不同分辨率额尺寸，代码，权重



应用程序数据分享带各大平台： 到平台上申请应用获取key然后将关联信息添加到自己的应用中。


## 12.jvm与dalvikvm ##

## 13.图片缓存技术 ##

加载大量图片带来的异常。
回收解决，性能问题
LruCash缓存类：原理使用linkedhashmap来存储图片使用算法Lru算法将元素按照使用的次数从少到多排序，并且在缓存达到预设值时及时将集合中最少使用的元素移除，但是内设的缓存预定值设置为多少要根据程序运行的情况来定。


使用缩放和lru算法缓存，构建敏感缓存




## 14.百度地图 ##

BMapManager   MapView  MapCotroller
mvc模式设计的三个类

本地搜索
MKSearch   MKListener    自己定义覆盖物，然后添加到mapview得数据集合里，   获得密钥。

## 15.网络编程 ##
两种方式，http   socket    

手机通信渠道，wifi   ,APN基站接入点，两种方式，wap net 

wap 地域服务器差别，      改用httpclient框架解决问题


移动端与PC端得通信方式
USB接口	   读取pdi uid  安卓驱动
wifi     udp方式向局域网所有IP扔一个数据包  如果安装了这个应用就能建立连接

socket   udp协议维护长连接，手机不定式访问服务器,反复的关闭和打开连接耗费资源。因此有效的做法是移动端和服务器端维护一个长连接。但是当连接空闲时手机底会在时间超时或者内存不足的时候将连接回收，解决的办法是间隔一段时间就向服务器中发送一个数据包，服务器同样也返回一个数据包，保持连接通道不空闲，这样连接不会被回收掉。
长连接机制：客户端与服务器端维护一个socket长连接，连接使用行跳帧的机制，即没间隔一段时间客户端与服务器端互相发送一些简单数据确认连接存在。

请求的同步异步，同步是指IO流操作将阻塞请求，即客户端发送一个请求，必须要等到服务器端响应才能发送另外一个请求，服务器端阻塞，没有处理外第一个请求不能可以处理其他请求，线程或者进程被挂起；请求异步是IO流操作将不阻塞请求，客户端可以连着发多个请求，服务器端非阻塞，即第一个请求没有处理完仍然可以处理其他请求。


多线程 + TCP实现  C/S结构聊天室：io流读取使用readline方法，每次读取一行，由于在readline方法返回成功之前线程阻塞，所以将服务器端和客户端的socket流的读取都放在子线程中。我们将一个客户端发来的数据发往所有的客户，因此使用一个集合来存储各个客户端发来soket请求。每次都将一个客户端得数据遍历发给所有的客户端。客户端使用一个文本和一个按钮来操作输入语句，给按钮设置监听事件，当点击时即将数据写入流中，在子线程中读取服务器端发来的数据并使用hanlder机制将数据传到主线程进行界面上的数据展示。



## 16.Webservice ##
将应用程序暴露成与平台无关语言无关的网络应用程序，以XML语言作为数据交互格式



## 17.JNI ##
概念，JVM支持一个调用接口，它允许将jvm嵌入本地程序。使用场景，操作硬件，游戏画面渲染，加密，速度快
JNI使用的CPU平台，Application.mK

开发流程：
1.eclipse关联ndk
2.使用android tools 中的add Native Support 给项目添加JNI文件夹，其中有包换android.mk和和c文件
3. 如果是JDK1.7在SRC目录下  如果是jdk1.6在bin classes目录下使用 javah -jni  完整类名获取头文件。
4. 将c文件中需要的jni类库，io类库，函数类库导入，将头文件中的方法粘贴进c文件，在方法中处理。给方法添加参数。
5. 配置path and sythmpols将jni头文件囊括进来，用于代码提示。
6. C通过反射调用java

## 18.项目说##

我的自我介绍：

您好，我叫王凯，安徽人,合肥工业大学211本科院校毕业。大学的专业不是软件相关类，但是由于个人偏爱编程在大三的暑假报了个培训班，学成之后又由于大四除了毕业设计基本没什么课了，于是就应了安徽科大讯飞的校招，做安卓开发，语音sdk一款语音转文字的sdk,期间还零星的做了些web的开发，有产品ebook商城。隔年八月份来到苏州科技园的苏州誉隆信息技术工作，当时公司的一款app产品苏州旅游做的不是很好，我们安卓组在苏州旅游的基础上载开发推出苏州新闻，相比较前者内容更加全面，性能更好。后期主要做些模块维护和版本迭代。四月份的时候，苏宁易购电子商务有限公司要做彩票，我们公司的上层和他们公司的上层有些交情，对方公司将一部分代码包给了我们公司，我当时主要负责双色球模块，彩票app的内容很多，项目比较大。
后来因女友在北工大读研异地。所以我就来北京了。





苏州新闻

从技术的苏州新闻角度说说这个项目

界面层
1.acitivty的使用
评价一个app得好坏我认为在项目中activity的数量是一个指标，一个activity得创建要经过很多繁琐的步骤非常耗费资源。而且一个应用中使用过多的activity，退出也是一件非常麻烦的事，网上提供了一些多个activity推出的方法，注入killprocess System.exit,但是当内存中activity过多时，虽然进程已经退出，但是这些acitivity仍然在内存中，又或者使用递归退出，抛出异常退出。这些都不是最优秀的做法。
最优秀的做法是我只用一个activity，当需要退出时直接finish掉即可。
activity就像是一个房子，我们的view全部都显示在pnonewindow这个窗户上，当我们需要展示不同的内容时，我们只需要将窗户上view替换就可以了，google后来推出fragment也是基于这样的原因。

苏州新闻项目只使用了三个activity，一个是首页，另外一个是介绍页，介绍页第一次进入应用开启，以后都不在开启，第三个就是内容。发挥最多作用的实际上就是内容activity。


2.视图搭建
整个界面由slidingmenue布局，双边菜单。
中间显示区域与两边的菜单分别使用fragment来填充。
左侧菜单主要是导航，listview来实现，给listview设置条目点击事件，当我点击时使用回调将索引位置传到actiivty中对点击进行切换页面的处理。
中间的fragment使用单例管理类进行管理，主要职责为切换页面，初始化页的管理类。页的管理类是什么，fragment相当于一个容器，容器中展示的内容就是来自页管理类，所有页的管理类都继承自已经定义好规则的抽象类，这个basepager主要约束子类必须做两件事情视图自检初始化，数据初始化。页的管理类是根据什么生成的，是根据请求过来的json数据，服务器端数据要求这些数据怎样展示都是事先定义好的。
新闻模块，中间容器展示newspager这个页管理类，也是整个项目中最重的模块。

先说下newspager的视图。
viewpager这个页面的视图主要是由viewpager构成，上面导航使用viewpagerindicator指针关联实现，双向关联，设置onpagerchangedlistener实现。

同样的，viewpager里的内容同样是个页管理类，我们翻动可以发现里面的视图结构都一样，这是因为他们使用都是同一个页的管理类，只是展示的数据不一样。
viewpager里主要使用pulltofreshlistview实现，头条目插入了继承于viewpager的扩展view.这个view只要输入一些图片地址就能自动播放，内部是这样实现的，在viewpager的页面切换的基础上使用handler递归累加变量取余后通过调用setCurrentItem()驱动自动切换页面。点击后会加载一个webview的详情页。说下handler机制补充----------》（UI主线程自动封装了Loop.prepare();  Loop.loop()两步，如果在子线程中使用handler需要手动补上这两步。loop.prepare()方法里new了消息泵looper，消息泵里创建了消息消息队列，并且将looper绑定到本地线程变量threadlocal里。Loop.loop(),方法从当前线程中获取了消息泵looper，并且设置了一个while(true)死循环，不断轮训消息队列中的消息，这个死循环中主要有三个api，一个事queue.next(),这是个从消息对垒取出下一个消息的方法，该方法阻塞，当没有消息或者位于消息队列最顶的消息的发送时间还没到都将一直阻塞，底层调用C语言实现。获取到消息后会会判断这个消息有没有发送者，如果么有发送者在丢弃，有则dispathmessage将事件发送者的handlemessage方法中，进行处理，分完外消息后调用recycle方法将消息回收到消息池，将消息的成员变量持有的引用清空，消息池中每个消息有个next属性用来记录另外一个消息，这样消息形成一条链存储，当我们使用调用消息的静态方法obtain时就是从消息池中获取，没有则new一个。我们在主线程创建handler时，handler内部从本地线程变量中获取消息泵，从消息泵中获取消息队列并缓存起来，当我们使用handler发送消息时，会将消息按照消息的发送时间重新排序，然后存放到消息队列中，这样就是用了子线程中不断发送数据到消息队列，主线程从消息队列获取消息的效果，我个人理解，认为这跟一个类的成员变量 在不通过的线程中不赋值是非常相似的，不过是即可显示的比如给我复制5那么主线程该变量就立马编程了5，给我复制10，又立马编程了10，唯一不同是这些消息可以按照时间进行排序，并且延时接受到这种变化）


3.遇到的问题：
当时在做的时候遇到两个事件传递的问题----》（叙述下事件传递机制：当我们手指触摸屏幕发生触摸事件时，系统有一个线程每隔20毫秒扫描屏幕就会拾取到事件并将事件解析成数据封装在montionevent中，主要包含事件的坐标，时间，动作等等，并且将事件发送的系统的消息队列中，另外有一个线程不断从这个消息对列中取事件传给当前位于当前最上面的acitivity，之所以能够将motionevent从系统传递到应用中是使用了aidl进程间通信技术，motionevent实现了parcelbale接口可以传递到共享内存中，acitivity获得事件后就调用dispatchevent方法分发给decorview，当时在分发之前留有一个空实现方法，叫做Userinteract()留给程序做一些屏幕触摸时的处理，比如触摸屏幕时屏幕亮度发生变化等等，decorview获得事件后也会调用dispatchevent方法将事件分发下去知道讲事件分发给发生down事件子view的onTouchEvent方法，如果该方法返回false不消费时间就会将事件传递给ontoch方法处理如果该方法返回false就会传递给上层的触摸处理器，返回true就代表消费事件，事件终止传递，如果没有view处理事件，那么时间最终回到activity的ontouch方法中，将事件关闭，不处理。我们常用的click事件是up事件的衍生物，longlick在down事件发生时就开始计时了，满足500毫秒就认为是长按事件，小于则认为是点击事件），翻看viewpager的源码可以知道viewpager使用onintercepter方法截断了所有事件的传递，这样viewpager里的子view是接受不到事件的，因此我将这个参数修改成了false，让事件继续传递。

另外在轮播图区域中图片滚动到最后一页时，会带到整个viewpager的滚动，这显然不是我们要的效果，出现这种现象是因为最后一页时事件被viewpager截获，因此在自定义viewpager的ontouch方法中当事件类型为down,up move cancel outsider类型时都设置父view   requestdisallowintercepterevent为true，即父view不截获事件。

另外向右滑动viewpager时会带动菜单打开，我们只需判断当前viewpager为第一页时才设置菜单可打开即可。

4.图片加载处理
为了提高用户体验，我加载图片使用了三级缓存，即http缓存，Httpclient自带。磁盘文件缓存，以及内存缓存。工作流程是这样的：第一次从网络上请求图片http自动缓存异步分图片，比如我们发送请求时服务器对比缓存内容事件与服务器端内容的时间，如果一样会给我们发送304状态码，表示内容未改变，请读缓存。将请求回来的图片存储到文件中在从文件中读取读片，这样做可以使用bitmapfactoryoption对图片做些缩放和内存优化处理，然后将图片读取到内存中，并展示出来，下一次在获取图片时，先从内存中获取，内存中没有就从文件中获取，文件中也没有就从网络中获取。那么着就怎样的内存缓存，常用的有两类，一类是软引用Map集合高速缓存。一类是lrucache混村类。分别说下，引用分为四种，强引用，软引用，若引用，虚引用，强引用时我们经常使用的那中方式，特点是内存就算发生OOM异常也不会回收该对象。软应用对象会在内存OOM之前回收该对象，并且可以和引用队列一起使用来追踪回收的对象，弱引用虚以用只用被GC扫描到就会被回收，与必须与引用对列一起使用，主要用来追踪被回收的对象，没什么太大作用。软引用GC的回收，在java中对软引用的描述是在系统抛出OOM异常之前会回收软应用对象，但是android系统对java改了不少，在内存充足的情况下有一定几率回收，并且GC并不是时时刻刻运行的，回收也是需要时间的，快速滑动图片可能时内存猛涨，gc来不及回收同样也会造成oom异常。因此软引用缓存的使用场景时gc必须能有回收对象的时间。少量图片可以使用软引用缓存。使用lrucache来缓存图片，它的核心是内部维护了一个linkedhashmap集合，这个集合使用list recent used算法翻译过来时最近最少使用算法，它会根据兑现的使用频率将对象在集合进行排序，我们使用lrucache缓存时给它设置一个预定缓存，当它缓存的图片超过这个预定值时就自动重写重写它的清除最少使用的对象。但是这个缓存类同样有缺陷，我们在使用时必须重写它的sizeof方法，返回存入对象的大小，默认返回一，这显然是不合理的。这就意味着我们存放的对象必须是可计算大小的，当某一天java提供方法能够计算所有对象的大小时这个类也就通用了，目前只能用在能计算大小的对象中如bitmap何inputstream，有方法getbytecount  getrowbyte*height ，我们使用这个类来缓存图片即可。文件存储我们使用disklrucache，非谷歌官方提供，但是得到了认可。作用于lrucache非常类似都是设定存储大小，超过则自动按照使用频率清除，不过是在磁盘上。



网络层

由于对数据没有进行复杂的逻辑处理，比如计算，核对，存储等等，因此直接省略了业务层，扩大了网络层，通过异步任务asynctask f发送httpclient请求获取数据然后使用bean封装将数据回调到界面即可。asynctask的execute方法进行方法增强，添加网络判断，如果没有网络则提示用户没有连网。



------------------------------------------------------

苏宁彩票

这个项目是外接的代码，当时我们项目组做了双色球福彩3D和大乐透。我负责的是双色球。

1.首先说下彩票是如何赚钱的。

彩票只有国家指定的公司才能做，市面上有很多公司都在做彩票，他们的数据最终都流向国家彩票数据库。并不是每个公司都能向国家申请做彩票的，必须有足够的实力和用户群，比如淘宝可以向国家申请彩票业务，但是一般的小公司就不行了，那么在市面上实际上一些小公司也在做彩票业务，这是为什么，因为他们是二级代理，向国家申请做彩票的公司是一级代理，实力雄厚，小公司要想做彩票向一级代理申请，将他们的数据给一级代理，一级代理负责统一将数据给国家彩票数据库。代理最多只有二级，多了就撞不到钱了。国家彩票允许资金在流动通道中有一定的损耗，代理就靠着写损耗来赚钱，比如两元钱，二级代理分百分之八，二级代理分百分之四，当然还有分一部分给支付公司，别小看这几个百分点，曾今算过一个二级代理如果有十万活跃用户，那么一个月内靠着几个百分点能赚上百万，所以是非常赚钱的行业。


2.协议封装
我们接到第一个任务就是传输数据协议的封装，它的数据传输协议使用的是xml格式的，因此接受服务器端数据和发送数据都需要序列化和解析xml，非常繁琐，还容易出错，因为请求类型很多，下面的body标签里的节点不一样，因此我将协议使用面向对象的思想进行了封装，封装的目的是处理公共部分，抽象特殊部分，这样我们在解析或者发送数据的时候就只需调用下相关的api即可，具体方式就节点对象化，并自动封装序列化方法，这样就算人员调动或者新员工入职也能快速上手。




3.界面统一管理
  整个界面主要分为三个模块标题中间容器，底部导航，其中标题和导航变化非常少，总共有五种对应关系，标题和底部使用单例的manager管理类管理，自己处理显示和隐藏条目。
  那么如何根据现实不同的内容显示不同的标题和底部呢。如果将中间容器的manager写在标题和底部导航的manager里面会导致耦合度过高，不便于以后的扩展和维护，比如我以后除了标题和底部导航需要随着中间容器的内容一起变换同时也需要扩展一个组件，这个组件的内容随着中间容器的内容一起动，这就不行了，我们可以使用观察者模式来进行模块之间的解耦，让中间容器管理类继承oberservable，其余的管理类继承oberserve，并且在activity中注册，当中间容器内容发生变动就通知观察者，并将变动内容的相关数据传递给观察者，观察则依据此信息做一些变动。

4.内容切换
  中间容器是一个framelaout性能比reletivelayout要高，我在这里模仿了fragment，切换页面时使用了两个addview  removeallview来进行页面的切换，并且在这两个方法的前后给页面自定义了两个生命周期方法onresume onpause，在onrusume里做些切换到该页面时的初始化方法，在离开页面时回收资源。并且使用lisklist来存储添加的页面，模拟返回键，当按返回键是，将移除当前view并将集合中的历史view拿出来展示。

5.所有的球都是使用扩展的gridview展示的，并且使用了三种选择方式来选择号码机选一注首选一注，摇晃手机选择一注。手选一株很简单，就是手指点击球，gridview的onitemclicklistener会拾取动作，并将位置存储到一个集合中记录，蓝球也是一样使用一个集合来记录，当我需要将选择的号码发送到购买模块时只需要从这个集合中取即可。当我在点一下选中的球时，就会将数据从这个集合中移除并且刷新界面改变view的显示状态。
球上面的放大镜效果是一个popupwindow里面塞了一个textview，因为即需要显示图片又要显示文字，并且将popupwindow移到了球的正上方，popupwindow主要有三个api  show  update dismiss，移动popupwindow使用update方法实现的。重写gridview的ontouch事件，我们将坐标通过pointTopostion这个方法将转换为view的索引，通过这个索引来获取gridview的子view，将popupwindow得锚改变成这个view就达到了移动的效果。
事件问题：因为gridview是一个可滑动的view因此当我们上下移动时gridview会将这个事件给吃掉，导致放大镜无法上下移动，我们只需在事件中调用disallowinterceptertouchevent让gridview不截获这个事件即可，这样放大镜就能上下移动。


6.手机摇晃选号
另外还可以使用摇晃来选择一注，如何判定用户在摇晃手机，使用加速度传感器，手机的三个轴上的加速度传感器是在不断以0.000000几变化着的，当用户摇晃手机时三个轴上的加速度会发生剧烈变化，我每隔100毫秒取一个数据包，并将相邻时间点的数据包三个轴向的加速度进行差值运算取绝对值，使用一个统计变量将其累加当累加量达到我设定的域值时我就认为用户在摇晃手机并且使用系统的振动器震动，并且判定是在摇晃手机的这种状态的后续处理通过回调的形式暴露出去，让程序员自己去决定要做什么，我在这里做的就是机选了一注号码，这个逻辑前面已经说过了。随机选择使用random使用并注意去重复。
  
最下面计算注数使用的是排列组合，cnr 而金额为注数乘以2.

7.购物车
上面的所有数据最后都封装到单例的购物车中，购物车中记录选择的号码，注数，金额等等，当我按确定时，就会切换到购物车内容展示页面

追号表示号码一致不变，守号。倍投表示加倍的押注，倍数越大中奖后获得的回报也越大。下面的数据变化原理与前面解释的一样。
当按付款的时候会做这样几件事情：是否满足一注，是否登录，余额是否够，是否获取了期次。不满足一注提示用户去投注，未登录就跳转到登陆模块登录获取金额这个登录不是我们购彩模块做的，判断是否登录只需要判断一个全局常量布尔值，购彩模块没有权利去修改这个布尔值只有登录模块才有，切换到登陆页面登录成功后在切换回来，关于登录了后跳转到那个页面我们可以手动指定，因为整个框架都是自己写的。


8.业务层
业务层主要处理发送协议数据，异步任务请求网络，判断网络状态，接受服务恢复数据并解析，由于彩票与钱打交道，所以数据安全级别要求较高，为了防止黑客抓包篡改，我们使用des对称加密对敏感数据进行了加密，并且为了防止数据被篡改，使用md5对数据和时间的组合进行了加密。在一方受到数据后先使用密钥对数据进行des解密，然后将明文和发送过来的时间合成md5加密的原始明文，将其进行Md5加密与发送过来的md5值进行对比，如果一样，那么说明数据没有被篡改。
并对这些数据进行解析，封装成bean传递到界面。
为了减低业务层与界面层的耦合度，使用工厂模式将实现类的类名配置的properties配置文件中进行加载。


9.优化，所有的页面第一次创建后都会存储到软引用集合中，这样获取时就不需要在new，提高性能。







视图层搭建

业务层搭建


网络层搭建


事件传递机制


第三方控件




